{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation Governing Equations The motion of a projectile under gravity (without air resistance) is governed by Newton\u2019s Second Law: \\[ \\frac{d^2 x}{dt^2} = 0, \\quad \\frac{d^2 y}{dt^2} = -g \\] Solving these, we get the velocity components: \\[ v_x = v_0 \\cos\\theta, \\quad v_y = v_0 \\sin\\theta - gt \\] And the position equations: \\[ x = v_0 \\cos\\theta \\cdot t, \\quad y = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 \\] where: - \\( v_0 \\) is the initial velocity, - \\( \\theta \\) is the launch angle, - \\( g \\) is the gravitational acceleration. Finding the Range The range \\( R \\) is found by solving for \\( x \\) when \\( y = 0 \\) (projectile returns to ground): \\[ t_f = \\frac{2 v_0 \\sin\\theta}{g} \\] Substituting into the equation for \\( x \\) : \\[ R = v_0 \\cos\\theta \\times \\frac{2 v_0 \\sin\\theta}{g} \\] Using the trigonometric identity \\( 2 \\sin\\theta \\cos\\theta = \\sin 2\\theta \\) , we get: \\[ R = \\frac{v_0^2}{g} \\sin 2\\theta \\] This shows the range depends on \\( \\sin 2\\theta \\) , with a maximum at \\( \\theta = 45^\\circ \\) . 2. Analysis of the Range The range is symmetric about \\( \\theta = 45^\\circ \\) , meaning complementary angles (e.g., \\( 30^\\circ \\) and \\( 60^\\circ \\) ) result in the same range. Increasing \\( v_0 \\) increases \\( R \\) quadratically. Increasing \\( g \\) (e.g., on different planets) decreases the range. 3. Practical Applications Sports: Optimizing shot put, long jump, or soccer kicks. Military: Artillery calculations. Space Science: Designing launch angles for rockets. Adding complexities like air resistance leads to asymmetric trajectories and reduced range. 4. Implementation in Python Click to expand Python code import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 20 # Initial velocity (m/s) g = 9.81 # Gravitational acceleration (m/s^2) angles = np.linspace(0, 90, 500) # Angles in degrees # Calculate range ranges = (v0**2 * np.sin(2 * np.radians(angles))) / g # Handle edge case where angle is 90 degrees ranges[np.isclose(angles, 90)] = 0 # Set range to 0 for 90 degrees # Plot plt.figure(figsize=(8, 6)) plt.plot(angles, ranges, label=f\"v0 = {v0} m/s, g = {g} m/s\u00b2\") plt.title(\"Range vs Angle of Projection\") plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.legend() plt.grid() # Save the plot as an image plt.savefig(\"range_vs_angle.png\", dpi=300) # Save as PNG with high resolution plt.show() 5. Graphical Representation Below is the graph showing the relationship between the range and the angle of projection: 6. Discussion on Limitations and Realistic Factors Limitations of the Idealized Model No Air Resistance: The model assumes no air resistance, which is unrealistic for most real-world scenarios. Air resistance reduces the range and makes the trajectory asymmetric. Constant Gravitational Acceleration: The model assumes \\( g \\) is constant, which is valid only for small distances near the Earth's surface. No Wind Effects: Wind can significantly alter the trajectory, either increasing or decreasing the range depending on its direction. Point Mass Assumption: The projectile is treated as a point mass, ignoring factors like shape, size, and spin. Suggestions for Incorporating Realistic Factors Air Resistance: Introduce drag force proportional to the velocity squared, \\( F_d = -c_d v^2 \\) , where \\( c_d \\) is the drag coefficient. Variable Gravity: For large distances, use \\( g = \\frac{GM}{(R+h)^2} \\) , where \\( h \\) is the height above the Earth's surface. Wind Effects: Add a horizontal force term to account for wind velocity. Projectile Shape and Spin: Include lift and Magnus forces for spinning projectiles. By incorporating these factors, the model can better represent real-world scenarios, though at the cost of increased computational complexity.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#governing-equations","text":"The motion of a projectile under gravity (without air resistance) is governed by Newton\u2019s Second Law: \\[ \\frac{d^2 x}{dt^2} = 0, \\quad \\frac{d^2 y}{dt^2} = -g \\] Solving these, we get the velocity components: \\[ v_x = v_0 \\cos\\theta, \\quad v_y = v_0 \\sin\\theta - gt \\] And the position equations: \\[ x = v_0 \\cos\\theta \\cdot t, \\quad y = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 \\] where: - \\( v_0 \\) is the initial velocity, - \\( \\theta \\) is the launch angle, - \\( g \\) is the gravitational acceleration.","title":"Governing Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#finding-the-range","text":"The range \\( R \\) is found by solving for \\( x \\) when \\( y = 0 \\) (projectile returns to ground): \\[ t_f = \\frac{2 v_0 \\sin\\theta}{g} \\] Substituting into the equation for \\( x \\) : \\[ R = v_0 \\cos\\theta \\times \\frac{2 v_0 \\sin\\theta}{g} \\] Using the trigonometric identity \\( 2 \\sin\\theta \\cos\\theta = \\sin 2\\theta \\) , we get: \\[ R = \\frac{v_0^2}{g} \\sin 2\\theta \\] This shows the range depends on \\( \\sin 2\\theta \\) , with a maximum at \\( \\theta = 45^\\circ \\) .","title":"Finding the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The range is symmetric about \\( \\theta = 45^\\circ \\) , meaning complementary angles (e.g., \\( 30^\\circ \\) and \\( 60^\\circ \\) ) result in the same range. Increasing \\( v_0 \\) increases \\( R \\) quadratically. Increasing \\( g \\) (e.g., on different planets) decreases the range.","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports: Optimizing shot put, long jump, or soccer kicks. Military: Artillery calculations. Space Science: Designing launch angles for rockets. Adding complexities like air resistance leads to asymmetric trajectories and reduced range.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-in-python","text":"Click to expand Python code import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 20 # Initial velocity (m/s) g = 9.81 # Gravitational acceleration (m/s^2) angles = np.linspace(0, 90, 500) # Angles in degrees # Calculate range ranges = (v0**2 * np.sin(2 * np.radians(angles))) / g # Handle edge case where angle is 90 degrees ranges[np.isclose(angles, 90)] = 0 # Set range to 0 for 90 degrees # Plot plt.figure(figsize=(8, 6)) plt.plot(angles, ranges, label=f\"v0 = {v0} m/s, g = {g} m/s\u00b2\") plt.title(\"Range vs Angle of Projection\") plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.legend() plt.grid() # Save the plot as an image plt.savefig(\"range_vs_angle.png\", dpi=300) # Save as PNG with high resolution plt.show()","title":"4. Implementation in Python"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-graphical-representation","text":"Below is the graph showing the relationship between the range and the angle of projection:","title":"5. Graphical Representation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#6-discussion-on-limitations-and-realistic-factors","text":"","title":"6. Discussion on Limitations and Realistic Factors"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations-of-the-idealized-model","text":"No Air Resistance: The model assumes no air resistance, which is unrealistic for most real-world scenarios. Air resistance reduces the range and makes the trajectory asymmetric. Constant Gravitational Acceleration: The model assumes \\( g \\) is constant, which is valid only for small distances near the Earth's surface. No Wind Effects: Wind can significantly alter the trajectory, either increasing or decreasing the range depending on its direction. Point Mass Assumption: The projectile is treated as a point mass, ignoring factors like shape, size, and spin.","title":"Limitations of the Idealized Model"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#suggestions-for-incorporating-realistic-factors","text":"Air Resistance: Introduce drag force proportional to the velocity squared, \\( F_d = -c_d v^2 \\) , where \\( c_d \\) is the drag coefficient. Variable Gravity: For large distances, use \\( g = \\frac{GM}{(R+h)^2} \\) , where \\( h \\) is the height above the Earth's surface. Wind Effects: Add a horizontal force term to account for wind velocity. Projectile Shape and Spin: Include lift and Magnus forces for spinning projectiles. By incorporating these factors, the model can better represent real-world scenarios, though at the cost of increased computational complexity.","title":"Suggestions for Incorporating Realistic Factors"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum \ud83e\udde0 General Solutions for the Forced Damped Pendulum 1. Full Nonlinear Equation The forced damped pendulum is governed by the second-order nonlinear ODE: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin(\\theta) = A\\cos(\\omega_d t) \\] This is nonlinear , non-autonomous , and second-order , with: - Damping : \\( b\\frac{d\\theta}{dt} \\) - Restoring force : \\( \\frac{g}{L} \\sin(\\theta) \\) - External driving : \\( A\\cos(\\omega_d t) \\) \u2757 General solutions to this equation cannot be written in closed form. Numerical techniques are necessary. 2. Python Implementation for Simulations Below is a Python script to simulate the forced damped pendulum and generate phase portraits, Poincar\u00e9 sections, and bifurcation diagrams. Click to expand Python code # filepath: /simulations/forced_damped_pendulum.py import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # gravitational acceleration (m/s^2) L = 1.0 # length of pendulum (m) b = 0.5 # damping coefficient A = 1.5 # driving amplitude omega_d = 2.0 # driving frequency # Define the ODE system def forced_damped_pendulum(t, y, b, g, L, A, omega_d): theta, omega = y dydt = [omega, -b * omega - (g / L) * np.sin(theta) + A * np.cos(omega_d * t)] return dydt # Solve the ODE t_span = (0, 50) y0 = [0.1, 0] # initial conditions: [theta, omega] t_eval = np.linspace(t_span[0], t_span[1], 1000) sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b, g, L, A, omega_d)) # Extract results theta = sol.y[0] omega = sol.y[1] time = sol.t # Plot Phase Portrait plt.figure(figsize=(8, 6)) plt.plot(theta, omega, label=\"Phase Portrait\") plt.xlabel(\"Theta (rad)\") plt.ylabel(\"Angular Velocity (rad/s)\") plt.title(\"Phase Portrait of Forced Damped Pendulum\") plt.legend() plt.grid() plt.show() # Poincar\u00e9 Section poincare_theta = theta[::50] poincare_omega = omega[::50] plt.figure(figsize=(8, 6)) plt.scatter(poincare_theta, poincare_omega, s=10, label=\"Poincar\u00e9 Section\") plt.xlabel(\"Theta (rad)\") plt.ylabel(\"Angular Velocity (rad/s)\") plt.title(\"Poincar\u00e9 Section of Forced Damped Pendulum\") plt.legend() plt.grid() plt.show() # Bifurcation Diagram (varying driving amplitude) amplitudes = np.linspace(0.5, 2.5, 50) bifurcation_data = [] for A in amplitudes: sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b, g, L, A, omega_d)) bifurcation_data.append(sol.y[0][-100:]) # last 100 points plt.figure(figsize=(8, 6)) for i, A in enumerate(amplitudes): plt.scatter([A] * len(bifurcation_data[i]), bifurcation_data[i], s=1, color=\"blue\") plt.xlabel(\"Driving Amplitude (A)\") plt.ylabel(\"Theta (rad)\") plt.title(\"Bifurcation Diagram of Forced Damped Pendulum\") plt.grid() plt.show() 3. Linearized Case (Small-Angle Approximation) For small oscillations \\( \\theta \\ll 1 \\) , we use: \\[ \\sin(\\theta) \\approx \\theta \\] Then the equation becomes: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A\\cos(\\omega_d t) \\] This is a linear inhomogeneous second-order ODE , with the general solution: \\[ \\theta(t) = \\theta_h(t) + \\theta_p(t) \\] \ud83d\udd39 Homogeneous Solution ( \\( \\theta_h \\) ): \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\omega_0^2 \\theta = 0 \\quad\\text{where } \\omega_0 = \\sqrt{\\frac{g}{L}} \\] Solving this gives: Underdamped : \\( b^2 < 4\\omega_0^2 \\) \\[ \\theta_h(t) = e^{-\\frac{b}{2}t}(C_1\\cos(\\omega_1 t) + C_2\\sin(\\omega_1 t)) \\quad \\text{where } \\omega_1 = \\sqrt{\\omega_0^2 - \\left(\\frac{b}{2}\\right)^2} \\] Critically damped : \\( b^2 = 4\\omega_0^2 \\) Overdamped : \\( b^2 > 4\\omega_0^2 \\) Each case leads to exponential decay of oscillations. \ud83d\udd39 Particular Solution ( \\( \\theta_p \\) ): We seek a steady-state solution of the form: \\[ \\theta_p(t) = B\\cos(\\omega_d t - \\delta) \\] Where: - \\( B \\) : amplitude of response - \\( \\delta \\) : phase shift between driving force and response Substitute into the linearized equation to get: \\[ B = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega_d^2)^2 + b^2\\omega_d^2}} \\\\ \\delta = \\tan^{-1}\\left( \\frac{b\\omega_d}{\\omega_0^2 - \\omega_d^2} \\right) \\] 4. Resonance Behavior Resonance occurs when the driving frequency \\( \\omega_d \\) is near the natural frequency \\( \\omega_0 \\) The system\u2019s response peaks when: \\[ \\omega_{\\text{res}} = \\sqrt{\\omega_0^2 - \\frac{b^2}{2}} \\] The amplitude increases dramatically unless damping \\( b \\) is large. 5. Numerical and Chaotic Solutions (Full Nonlinear Case) For larger amplitudes, the small-angle approximation breaks down, and nonlinear effects dominate , especially when: - \\( A \\) is large (strong driving) - \\( b \\) is small (weak damping) \ud83c\udf2a Chaos Emerges When: There's sensitive dependence on initial conditions The system exhibits non-periodic, bounded trajectories Phase space trajectories fill a region instead of forming closed loops These must be analyzed using: - Numerical Integration (e.g., Runge-Kutta) - Poincar\u00e9 Maps - Lyapunov Exponents - Bifurcation Diagrams 6. Summary of Behavior by Regime Regime Behavior Solution Type Small-angle, no drive Simple Harmonic Motion Analytic Small-angle, with drive Linear resonance Analytic (steady-state + decay) Full equation, weak drive Quasiperiodic or periodic Numerical Full equation, strong drive Chaotic Numerical Graphical Representations of Motion The plots below show the angular motion of the forced damped pendulum under various parameter regimes: \ud83e\udde9 Limitations and Potential Extensions \ud83d\udd3b Limitations of the Model Small-Angle Approximation (Linearization) The analytical solution assumes \\( \\sin(\\theta) \\approx \\theta \\) , which is only valid for small angles (typically \\( \\theta < 15^\\circ \\) ). For larger amplitudes, this approximation breaks down, and nonlinear effects become significant. Simplified Damping Term The damping is modeled as linear (proportional to angular velocity), which is an idealization. Real-world systems may have more complex damping, including: Nonlinear damping (e.g., quadratic air resistance) Hysteresis damping (seen in materials like rubber) Purely Periodic Driving Force The external driving force is assumed to be sinusoidal. This limits the exploration of real-world driving signals, which can be irregular, random, or pulsed. Single-Degree-of-Freedom System The model treats the pendulum as a point mass on a rigid rod in 2D. It doesn\u2019t account for: Flexibility in the arm Multi-link or compound pendulums Effects like torque from a rotational base \ud83c\udf31 Possible Extensions Nonlinear Damping Models Introduce damping proportional to \\( \\omega^2 \\) or a combination of linear and quadratic terms: $$ \\frac{d^2\\theta}{dt^2} + b_1 \\frac{d\\theta}{dt} + b_2\\left( \\frac{d\\theta}{dt} \\right)^2 + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega_d t) $$ Here: - \\( b_1 \\) : Linear damping coefficient (proportional to velocity). - \\( b_2 \\) : Nonlinear damping coefficient (proportional to the square of velocity). - The term \\( b_2 \\left( \\frac{d\\theta}{dt} \\right)^2 \\) accounts for effects like air resistance at higher speeds. Non-Periodic or Stochastic Forcing Replace the cosine term with: Square waves or pulse trains (digital actuation) Random noise (to model real-world perturbations) Multi-frequency or modulated driving forces Coupled Pendula or Multi-DOF Systems Study interactions between multiple pendulums (e.g., coupled oscillators or pendulum-on-cart systems) to simulate real engineering systems or molecular dynamics. Chaotic Control and Synchronization Extend into chaos control techniques, such as: Feedback control to stabilize unstable orbits Phase-locking and synchronization of multiple chaotic systems Energy Harvesting Models Modify the system to explore how mechanical energy from environmental oscillations (wind, waves, etc.) could be harvested efficiently under chaotic regimes. \ud83d\udcca Phase Portraits, Poincar\u00e9 Sections, and Bifurcation Diagrams \ud83d\udd39 Phase Portraits A phase portrait provides a graphical representation of a system's trajectories in phase space (typically angle vs. angular velocity for the pendulum). These portraits illustrate the behavior of the system over time and can show: - Periodic motion : Closed curves indicating regular oscillations. - Chaotic motion : Dense, non-periodic trajectories filling a region of phase space. For the forced damped pendulum, we can visualize the transition from regular oscillations to chaos by plotting the system\u2019s state variables \\( (\\theta, \\omega) \\) at various time steps. Phase portraits are helpful for identifying: - Stable limit cycles for periodic motion. - Attractors for chaotic or quasiperiodic motion. \ud83d\udd39 Poincar\u00e9 Sections A Poincar\u00e9 section is a way to reduce continuous dynamics to a discrete map by sampling the state of the system at regular intervals or at specific moments (e.g., when \\( \\theta = 0 \\) ). This technique is especially useful for understanding chaotic systems. By plotting points in the state space at these sampling moments, we can reveal: - Periodic orbits : Represented by distinct points or loops. - Strange attractors : Points clustered in irregular regions, indicative of chaotic dynamics. The Poincar\u00e9 section helps identify the underlying structure of the system's dynamics by providing a snapshot of the system's behavior in a lower-dimensional subspace. \ud83d\udd39 Bifurcation Diagrams A bifurcation diagram shows how the equilibrium states or periodic orbits of a system change as a system parameter (e.g., driving amplitude \\(A\\) or frequency \\( \\omega_d \\) ) is varied. This diagram helps: - Identify critical parameter values where the system undergoes transitions from periodic to chaotic behavior (bifurcations). - Visualize the onset of chaos : Small variations in parameters may cause sudden qualitative changes in the system's motion, such as period-doubling bifurcations or the appearance of strange attractors. In the case of the forced damped pendulum, varying the amplitude \\(A\\) or frequency \\( \\omega_d \\) of the external driving force can lead to dramatic changes in the system\u2019s dynamics. A bifurcation diagram maps out these transitions and helps identify chaotic windows and periodic regions. Example Implementation and Visualization To explore these concepts further, Python can be used to generate phase portraits, Poincar\u00e9 sections, and bifurcation diagrams. This allows us to visualize the transition from regular to chaotic dynamics as the parameters (such as damping, driving force, and frequency) are varied. By plotting the system\u2019s trajectories over time and capturing regular orbits in the Poincar\u00e9 section, we can uncover complex dynamics that are not evident from the raw time series alone. \ud83d\udcdd Conclusion Phase portraits, Poincar\u00e9 sections, and bifurcation diagrams are essential tools in the study of nonlinear dynamics and chaos theory. These techniques help simplify complex systems and allow us to visualize and understand the transitions from ordered to chaotic behavior in a variety of physical systems, including the forced damped pendulum.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#general-solutions-for-the-forced-damped-pendulum","text":"","title":"\ud83e\udde0 General Solutions for the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-full-nonlinear-equation","text":"The forced damped pendulum is governed by the second-order nonlinear ODE: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin(\\theta) = A\\cos(\\omega_d t) \\] This is nonlinear , non-autonomous , and second-order , with: - Damping : \\( b\\frac{d\\theta}{dt} \\) - Restoring force : \\( \\frac{g}{L} \\sin(\\theta) \\) - External driving : \\( A\\cos(\\omega_d t) \\) \u2757 General solutions to this equation cannot be written in closed form. Numerical techniques are necessary.","title":"1. Full Nonlinear Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-python-implementation-for-simulations","text":"Below is a Python script to simulate the forced damped pendulum and generate phase portraits, Poincar\u00e9 sections, and bifurcation diagrams. Click to expand Python code # filepath: /simulations/forced_damped_pendulum.py import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # gravitational acceleration (m/s^2) L = 1.0 # length of pendulum (m) b = 0.5 # damping coefficient A = 1.5 # driving amplitude omega_d = 2.0 # driving frequency # Define the ODE system def forced_damped_pendulum(t, y, b, g, L, A, omega_d): theta, omega = y dydt = [omega, -b * omega - (g / L) * np.sin(theta) + A * np.cos(omega_d * t)] return dydt # Solve the ODE t_span = (0, 50) y0 = [0.1, 0] # initial conditions: [theta, omega] t_eval = np.linspace(t_span[0], t_span[1], 1000) sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b, g, L, A, omega_d)) # Extract results theta = sol.y[0] omega = sol.y[1] time = sol.t # Plot Phase Portrait plt.figure(figsize=(8, 6)) plt.plot(theta, omega, label=\"Phase Portrait\") plt.xlabel(\"Theta (rad)\") plt.ylabel(\"Angular Velocity (rad/s)\") plt.title(\"Phase Portrait of Forced Damped Pendulum\") plt.legend() plt.grid() plt.show() # Poincar\u00e9 Section poincare_theta = theta[::50] poincare_omega = omega[::50] plt.figure(figsize=(8, 6)) plt.scatter(poincare_theta, poincare_omega, s=10, label=\"Poincar\u00e9 Section\") plt.xlabel(\"Theta (rad)\") plt.ylabel(\"Angular Velocity (rad/s)\") plt.title(\"Poincar\u00e9 Section of Forced Damped Pendulum\") plt.legend() plt.grid() plt.show() # Bifurcation Diagram (varying driving amplitude) amplitudes = np.linspace(0.5, 2.5, 50) bifurcation_data = [] for A in amplitudes: sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b, g, L, A, omega_d)) bifurcation_data.append(sol.y[0][-100:]) # last 100 points plt.figure(figsize=(8, 6)) for i, A in enumerate(amplitudes): plt.scatter([A] * len(bifurcation_data[i]), bifurcation_data[i], s=1, color=\"blue\") plt.xlabel(\"Driving Amplitude (A)\") plt.ylabel(\"Theta (rad)\") plt.title(\"Bifurcation Diagram of Forced Damped Pendulum\") plt.grid() plt.show()","title":"2. Python Implementation for Simulations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-linearized-case-small-angle-approximation","text":"For small oscillations \\( \\theta \\ll 1 \\) , we use: \\[ \\sin(\\theta) \\approx \\theta \\] Then the equation becomes: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A\\cos(\\omega_d t) \\] This is a linear inhomogeneous second-order ODE , with the general solution: \\[ \\theta(t) = \\theta_h(t) + \\theta_p(t) \\]","title":"3. Linearized Case (Small-Angle Approximation)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#homogeneous-solution-theta_h","text":"\\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\omega_0^2 \\theta = 0 \\quad\\text{where } \\omega_0 = \\sqrt{\\frac{g}{L}} \\] Solving this gives: Underdamped : \\( b^2 < 4\\omega_0^2 \\) \\[ \\theta_h(t) = e^{-\\frac{b}{2}t}(C_1\\cos(\\omega_1 t) + C_2\\sin(\\omega_1 t)) \\quad \\text{where } \\omega_1 = \\sqrt{\\omega_0^2 - \\left(\\frac{b}{2}\\right)^2} \\] Critically damped : \\( b^2 = 4\\omega_0^2 \\) Overdamped : \\( b^2 > 4\\omega_0^2 \\) Each case leads to exponential decay of oscillations.","title":"\ud83d\udd39 Homogeneous Solution (\\( \\theta_h \\)):"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#particular-solution-theta_p","text":"We seek a steady-state solution of the form: \\[ \\theta_p(t) = B\\cos(\\omega_d t - \\delta) \\] Where: - \\( B \\) : amplitude of response - \\( \\delta \\) : phase shift between driving force and response Substitute into the linearized equation to get: \\[ B = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega_d^2)^2 + b^2\\omega_d^2}} \\\\ \\delta = \\tan^{-1}\\left( \\frac{b\\omega_d}{\\omega_0^2 - \\omega_d^2} \\right) \\]","title":"\ud83d\udd39 Particular Solution (\\( \\theta_p \\)):"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-resonance-behavior","text":"Resonance occurs when the driving frequency \\( \\omega_d \\) is near the natural frequency \\( \\omega_0 \\) The system\u2019s response peaks when: \\[ \\omega_{\\text{res}} = \\sqrt{\\omega_0^2 - \\frac{b^2}{2}} \\] The amplitude increases dramatically unless damping \\( b \\) is large.","title":"4. Resonance Behavior"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-numerical-and-chaotic-solutions-full-nonlinear-case","text":"For larger amplitudes, the small-angle approximation breaks down, and nonlinear effects dominate , especially when: - \\( A \\) is large (strong driving) - \\( b \\) is small (weak damping)","title":"5. Numerical and Chaotic Solutions (Full Nonlinear Case)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#chaos-emerges-when","text":"There's sensitive dependence on initial conditions The system exhibits non-periodic, bounded trajectories Phase space trajectories fill a region instead of forming closed loops These must be analyzed using: - Numerical Integration (e.g., Runge-Kutta) - Poincar\u00e9 Maps - Lyapunov Exponents - Bifurcation Diagrams","title":"\ud83c\udf2a Chaos Emerges When:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-summary-of-behavior-by-regime","text":"Regime Behavior Solution Type Small-angle, no drive Simple Harmonic Motion Analytic Small-angle, with drive Linear resonance Analytic (steady-state + decay) Full equation, weak drive Quasiperiodic or periodic Numerical Full equation, strong drive Chaotic Numerical","title":"6. Summary of Behavior by Regime"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#graphical-representations-of-motion","text":"The plots below show the angular motion of the forced damped pendulum under various parameter regimes:","title":"Graphical Representations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#limitations-and-potential-extensions","text":"","title":"\ud83e\udde9 Limitations and Potential Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#limitations-of-the-model","text":"Small-Angle Approximation (Linearization) The analytical solution assumes \\( \\sin(\\theta) \\approx \\theta \\) , which is only valid for small angles (typically \\( \\theta < 15^\\circ \\) ). For larger amplitudes, this approximation breaks down, and nonlinear effects become significant. Simplified Damping Term The damping is modeled as linear (proportional to angular velocity), which is an idealization. Real-world systems may have more complex damping, including: Nonlinear damping (e.g., quadratic air resistance) Hysteresis damping (seen in materials like rubber) Purely Periodic Driving Force The external driving force is assumed to be sinusoidal. This limits the exploration of real-world driving signals, which can be irregular, random, or pulsed. Single-Degree-of-Freedom System The model treats the pendulum as a point mass on a rigid rod in 2D. It doesn\u2019t account for: Flexibility in the arm Multi-link or compound pendulums Effects like torque from a rotational base","title":"\ud83d\udd3b Limitations of the Model"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#possible-extensions","text":"Nonlinear Damping Models Introduce damping proportional to \\( \\omega^2 \\) or a combination of linear and quadratic terms: $$ \\frac{d^2\\theta}{dt^2} + b_1 \\frac{d\\theta}{dt} + b_2\\left( \\frac{d\\theta}{dt} \\right)^2 + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega_d t) $$ Here: - \\( b_1 \\) : Linear damping coefficient (proportional to velocity). - \\( b_2 \\) : Nonlinear damping coefficient (proportional to the square of velocity). - The term \\( b_2 \\left( \\frac{d\\theta}{dt} \\right)^2 \\) accounts for effects like air resistance at higher speeds. Non-Periodic or Stochastic Forcing Replace the cosine term with: Square waves or pulse trains (digital actuation) Random noise (to model real-world perturbations) Multi-frequency or modulated driving forces Coupled Pendula or Multi-DOF Systems Study interactions between multiple pendulums (e.g., coupled oscillators or pendulum-on-cart systems) to simulate real engineering systems or molecular dynamics. Chaotic Control and Synchronization Extend into chaos control techniques, such as: Feedback control to stabilize unstable orbits Phase-locking and synchronization of multiple chaotic systems Energy Harvesting Models Modify the system to explore how mechanical energy from environmental oscillations (wind, waves, etc.) could be harvested efficiently under chaotic regimes.","title":"\ud83c\udf31 Possible Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#phase-portraits-poincare-sections-and-bifurcation-diagrams","text":"","title":"\ud83d\udcca Phase Portraits, Poincar\u00e9 Sections, and Bifurcation Diagrams"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#phase-portraits","text":"A phase portrait provides a graphical representation of a system's trajectories in phase space (typically angle vs. angular velocity for the pendulum). These portraits illustrate the behavior of the system over time and can show: - Periodic motion : Closed curves indicating regular oscillations. - Chaotic motion : Dense, non-periodic trajectories filling a region of phase space. For the forced damped pendulum, we can visualize the transition from regular oscillations to chaos by plotting the system\u2019s state variables \\( (\\theta, \\omega) \\) at various time steps. Phase portraits are helpful for identifying: - Stable limit cycles for periodic motion. - Attractors for chaotic or quasiperiodic motion.","title":"\ud83d\udd39 Phase Portraits"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#poincare-sections","text":"A Poincar\u00e9 section is a way to reduce continuous dynamics to a discrete map by sampling the state of the system at regular intervals or at specific moments (e.g., when \\( \\theta = 0 \\) ). This technique is especially useful for understanding chaotic systems. By plotting points in the state space at these sampling moments, we can reveal: - Periodic orbits : Represented by distinct points or loops. - Strange attractors : Points clustered in irregular regions, indicative of chaotic dynamics. The Poincar\u00e9 section helps identify the underlying structure of the system's dynamics by providing a snapshot of the system's behavior in a lower-dimensional subspace.","title":"\ud83d\udd39 Poincar\u00e9 Sections"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#bifurcation-diagrams","text":"A bifurcation diagram shows how the equilibrium states or periodic orbits of a system change as a system parameter (e.g., driving amplitude \\(A\\) or frequency \\( \\omega_d \\) ) is varied. This diagram helps: - Identify critical parameter values where the system undergoes transitions from periodic to chaotic behavior (bifurcations). - Visualize the onset of chaos : Small variations in parameters may cause sudden qualitative changes in the system's motion, such as period-doubling bifurcations or the appearance of strange attractors. In the case of the forced damped pendulum, varying the amplitude \\(A\\) or frequency \\( \\omega_d \\) of the external driving force can lead to dramatic changes in the system\u2019s dynamics. A bifurcation diagram maps out these transitions and helps identify chaotic windows and periodic regions.","title":"\ud83d\udd39 Bifurcation Diagrams"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#example-implementation-and-visualization","text":"To explore these concepts further, Python can be used to generate phase portraits, Poincar\u00e9 sections, and bifurcation diagrams. This allows us to visualize the transition from regular to chaotic dynamics as the parameters (such as damping, driving force, and frequency) are varied. By plotting the system\u2019s trajectories over time and capturing regular orbits in the Poincar\u00e9 section, we can uncover complex dynamics that are not evident from the raw time series alone.","title":"Example Implementation and Visualization"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"Phase portraits, Poincar\u00e9 sections, and bifurcation diagrams are essential tools in the study of nonlinear dynamics and chaos theory. These techniques help simplify complex systems and allow us to visualize and understand the transitions from ordered to chaotic behavior in a variety of physical systems, including the forced damped pendulum.","title":"\ud83d\udcdd Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius 1. Derivation of the Relationship We start with Newton\u2019s Law of Gravitation and the formula for centripetal force. Gravitational Force: $$ F_g = \\frac{G M m}{r^2} $$ Centripetal Force: $$ F_c = \\frac{m v^2}{r} $$ Equating the two forces for a body in circular orbit: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Canceling \\( m \\) and solving for \\( v \\) : \\[ v^2 = \\frac{G M}{r} \\] The orbital period \\( T \\) is related to the velocity and orbital radius by: \\[ v = \\frac{2\\pi r}{T} \\] Substitute into the velocity equation: \\[ \\left( \\frac{2\\pi r}{T} \\right)^2 = \\frac{G M}{r} \\] \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] Solving for \\( T^2 \\) : \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] \u2705 This shows that \\( T^2 \\propto r^3 \\) , which is Kepler\u2019s Third Law for circular orbits. 2. Python Implementation for Simulations Below is a Python script to simulate the relationship between orbital period and radius for circular orbits: Click to expand Python code # filepath: /simulations/keplers_law_simulation.py import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) # Orbital radii (in meters) radii = np.linspace(1e7, 5e8, 100) # Periods from Kepler's Third Law periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Plot T^2 vs r^3 plt.figure(figsize=(8, 5)) plt.plot(radii**3, periods**2, label='T\u00b2 vs r\u00b3', color='blue') plt.xlabel('r\u00b3 (m\u00b3)') plt.ylabel('T\u00b2 (s\u00b2)') plt.title(\"Verification of Kepler's Third Law\") plt.grid(True) plt.legend() plt.tight_layout() # Save the figure as a PNG image plt.savefig(\"keplers_law_plot.png\", dpi=300) # Optionally display it plt.show() 3. Implications for Astronomy This relationship allows astronomers to: Determine the mass of a central body (e.g., a star or planet) by observing the motion of orbiting objects. Calculate orbital distances when the period is known. Model the structure and scale of planetary systems. It supports the understanding of exoplanetary systems by enabling inference of planetary positions and masses from light curves and Doppler shifts. It's essential in satellite design and space mission planning , ensuring correct orbital parameters for stable orbits. 4. Real-World Examples Example 1: Moon\u2019s Orbit Around Earth Mean radius \\( r = 3.84 \\times 10^8 \\, \\text{m} \\) Orbital period \\( T = 27.3 \\, \\text{days} = 2.36 \\times 10^6 \\, \\text{s} \\) Calculate \\( \\frac{T^2}{r^3} \\) : \\[ \\frac{(2.36 \\times 10^6)^2}{(3.84 \\times 10^8)^3} \\approx 4.95 \\times 10^{-14} \\, \\text{s}^2/\\text{m}^3 \\] Example 2: Earth's Orbit Around the Sun Radius \\( r = 1.496 \\times 10^{11} \\, \\text{m} \\) Period \\( T = 365.25 \\, \\text{days} = 3.156 \\times 10^7 \\, \\text{s} \\) \\[ \\frac{(3.156 \\times 10^7)^2}{(1.496 \\times 10^{11})^3} \\approx 2.97 \\times 10^{-19} \\, \\text{s}^2/\\text{m}^3 \\] These values align with Kepler\u2019s Law and confirm its consistency across vastly different systems. 5. Computational Model Output \ud83d\udcf7 Kepler's Third Law: Simulation Plot \u2705 This simulation confirms a linear relationship between \\( T^2 \\) and \\( r^3 \\) , visually validating Kepler\u2019s Third Law.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-derivation-of-the-relationship","text":"We start with Newton\u2019s Law of Gravitation and the formula for centripetal force. Gravitational Force: $$ F_g = \\frac{G M m}{r^2} $$ Centripetal Force: $$ F_c = \\frac{m v^2}{r} $$ Equating the two forces for a body in circular orbit: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Canceling \\( m \\) and solving for \\( v \\) : \\[ v^2 = \\frac{G M}{r} \\] The orbital period \\( T \\) is related to the velocity and orbital radius by: \\[ v = \\frac{2\\pi r}{T} \\] Substitute into the velocity equation: \\[ \\left( \\frac{2\\pi r}{T} \\right)^2 = \\frac{G M}{r} \\] \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] Solving for \\( T^2 \\) : \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] \u2705 This shows that \\( T^2 \\propto r^3 \\) , which is Kepler\u2019s Third Law for circular orbits.","title":"1. Derivation of the Relationship"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-python-implementation-for-simulations","text":"Below is a Python script to simulate the relationship between orbital period and radius for circular orbits: Click to expand Python code # filepath: /simulations/keplers_law_simulation.py import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) # Orbital radii (in meters) radii = np.linspace(1e7, 5e8, 100) # Periods from Kepler's Third Law periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Plot T^2 vs r^3 plt.figure(figsize=(8, 5)) plt.plot(radii**3, periods**2, label='T\u00b2 vs r\u00b3', color='blue') plt.xlabel('r\u00b3 (m\u00b3)') plt.ylabel('T\u00b2 (s\u00b2)') plt.title(\"Verification of Kepler's Third Law\") plt.grid(True) plt.legend() plt.tight_layout() # Save the figure as a PNG image plt.savefig(\"keplers_law_plot.png\", dpi=300) # Optionally display it plt.show()","title":"2. Python Implementation for Simulations"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-implications-for-astronomy","text":"This relationship allows astronomers to: Determine the mass of a central body (e.g., a star or planet) by observing the motion of orbiting objects. Calculate orbital distances when the period is known. Model the structure and scale of planetary systems. It supports the understanding of exoplanetary systems by enabling inference of planetary positions and masses from light curves and Doppler shifts. It's essential in satellite design and space mission planning , ensuring correct orbital parameters for stable orbits.","title":"3. Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-real-world-examples","text":"","title":"4. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-1-moons-orbit-around-earth","text":"Mean radius \\( r = 3.84 \\times 10^8 \\, \\text{m} \\) Orbital period \\( T = 27.3 \\, \\text{days} = 2.36 \\times 10^6 \\, \\text{s} \\) Calculate \\( \\frac{T^2}{r^3} \\) : \\[ \\frac{(2.36 \\times 10^6)^2}{(3.84 \\times 10^8)^3} \\approx 4.95 \\times 10^{-14} \\, \\text{s}^2/\\text{m}^3 \\]","title":"Example 1: Moon\u2019s Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-2-earths-orbit-around-the-sun","text":"Radius \\( r = 1.496 \\times 10^{11} \\, \\text{m} \\) Period \\( T = 365.25 \\, \\text{days} = 3.156 \\times 10^7 \\, \\text{s} \\) \\[ \\frac{(3.156 \\times 10^7)^2}{(1.496 \\times 10^{11})^3} \\approx 2.97 \\times 10^{-19} \\, \\text{s}^2/\\text{m}^3 \\] These values align with Kepler\u2019s Law and confirm its consistency across vastly different systems.","title":"Example 2: Earth's Orbit Around the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-computational-model-output","text":"\ud83d\udcf7 Kepler's Third Law: Simulation Plot \u2705 This simulation confirms a linear relationship between \\( T^2 \\) and \\( r^3 \\) , visually validating Kepler\u2019s Third Law.","title":"5. Computational Model Output"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities 1. Definitions of Cosmic Velocities First Cosmic Velocity (Orbital Velocity): The minimum velocity required to achieve a stable circular orbit just above a planet\u2019s surface. $$ v_1 = \\sqrt{\\frac{G M}{R}} $$ Second Cosmic Velocity (Escape Velocity): The velocity required to completely escape the gravitational field of a planet without further propulsion. $$ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2 G M}{R}} $$ Third Cosmic Velocity (Solar System Escape): The velocity needed to escape the gravitational field of the Sun from Earth\u2019s orbit. $$ v_3 = \\sqrt{v_{e,\\text{sun}}^2 + v_\\text{earth}^2} $$ where \\( v_{e,\\text{sun}} \\) is the Sun escape velocity from Earth\u2019s orbit and \\( v_\\text{earth} \\) is Earth\u2019s orbital speed around the Sun. 2. Mathematical Derivations Starting from Newton\u2019s law of universal gravitation: Gravitational potential energy: $$ U = -\\frac{G M m}{R} $$ Kinetic energy: $$ K = \\frac{1}{2} m v^2 $$ To escape gravity, total energy must be zero: $$ K + U = 0 \\Rightarrow \\frac{1}{2} m v^2 = \\frac{G M m}{R} \\Rightarrow v = \\sqrt{\\frac{2 G M}{R}} $$ This is the escape velocity (second cosmic velocity) . 3. Python Simulation Click to expand Python code # filepath: /docs/1 Physics/2 Gravity/cosmic_velocities_simulation.py import matplotlib.pyplot as plt import numpy as np # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) # Data for celestial bodies planets = { \"Earth\": {\"radius\": 6.371e6, \"mass\": 5.972e24}, \"Mars\": {\"radius\": 3.39e6, \"mass\": 6.39e23}, \"Jupiter\": {\"radius\": 6.9911e7, \"mass\": 1.898e27}, } # Calculate velocities results = {} for planet, data in planets.items(): R = data[\"radius\"] M = data[\"mass\"] v1 = np.sqrt(G * M / R) # First cosmic velocity v2 = np.sqrt(2) * v1 # Second cosmic velocity results[planet] = {\"v1\": v1 / 1000, \"v2\": v2 / 1000} # Convert to km/s # Visualization labels = list(results.keys()) v1_values = [results[planet][\"v1\"] for planet in labels] v2_values = [results[planet][\"v2\"] for planet in labels] x = np.arange(len(labels)) width = 0.35 fig, ax = plt.subplots() bar1 = ax.bar(x - width/2, v1_values, width, label=\"First Cosmic Velocity (v\u2081)\") bar2 = ax.bar(x + width/2, v2_values, width, label=\"Second Cosmic Velocity (v\u2082)\") ax.set_xlabel(\"Planets\") ax.set_ylabel(\"Velocity (km/s)\") ax.set_title(\"Cosmic Velocities for Various Planets\") ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.tight_layout() plt.savefig(\"./images/cosmic_velocities.png\") plt.show() 4. Calculations for Earth, Mars, and Jupiter Planet Radius (km) Mass (kg) v\u2081 (km/s) v\u2082 (km/s) Earth 6,371 5.972 \u00d7 10\u00b2\u2074 7.91 11.2 Mars 3,390 6.39 \u00d7 10\u00b2\u00b3 3.55 5.03 Jupiter 69,911 1.898 \u00d7 10\u00b2\u2077 42.1 59.5 Note: First cosmic velocity \\( v_1 = \\sqrt{\\frac{G M}{R}} \\) Second cosmic velocity \\( v_2 = \\sqrt{\\frac{2 G M}{R}} \\) 5. Visualization \ud83d\udcca Cosmic Velocities by Planet (You can generate this chart using matplotlib, plotting v\u2081 and v\u2082 side-by-side for each planet.) 6. Importance in Space Exploration First Cosmic Velocity: Used to place satellites into orbit (e.g., GPS, weather satellites). Second Cosmic Velocity: Required for interplanetary travel (e.g., Moon missions, Mars rovers). Third Cosmic Velocity: Relevant for interstellar missions (e.g., Voyager probes, theoretical deep space travel). These thresholds determine fuel requirements, propulsion design, and mission feasibility. Conclusion Understanding and applying cosmic velocities enables humanity to navigate space\u2014from orbiting Earth to reaching distant stars. Their derivation from basic physical laws illustrates the power of physics to guide cutting-edge technology and exploration.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-definitions-of-cosmic-velocities","text":"First Cosmic Velocity (Orbital Velocity): The minimum velocity required to achieve a stable circular orbit just above a planet\u2019s surface. $$ v_1 = \\sqrt{\\frac{G M}{R}} $$ Second Cosmic Velocity (Escape Velocity): The velocity required to completely escape the gravitational field of a planet without further propulsion. $$ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2 G M}{R}} $$ Third Cosmic Velocity (Solar System Escape): The velocity needed to escape the gravitational field of the Sun from Earth\u2019s orbit. $$ v_3 = \\sqrt{v_{e,\\text{sun}}^2 + v_\\text{earth}^2} $$ where \\( v_{e,\\text{sun}} \\) is the Sun escape velocity from Earth\u2019s orbit and \\( v_\\text{earth} \\) is Earth\u2019s orbital speed around the Sun.","title":"1. Definitions of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-mathematical-derivations","text":"Starting from Newton\u2019s law of universal gravitation: Gravitational potential energy: $$ U = -\\frac{G M m}{R} $$ Kinetic energy: $$ K = \\frac{1}{2} m v^2 $$ To escape gravity, total energy must be zero: $$ K + U = 0 \\Rightarrow \\frac{1}{2} m v^2 = \\frac{G M m}{R} \\Rightarrow v = \\sqrt{\\frac{2 G M}{R}} $$ This is the escape velocity (second cosmic velocity) .","title":"2. Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-python-simulation","text":"Click to expand Python code # filepath: /docs/1 Physics/2 Gravity/cosmic_velocities_simulation.py import matplotlib.pyplot as plt import numpy as np # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) # Data for celestial bodies planets = { \"Earth\": {\"radius\": 6.371e6, \"mass\": 5.972e24}, \"Mars\": {\"radius\": 3.39e6, \"mass\": 6.39e23}, \"Jupiter\": {\"radius\": 6.9911e7, \"mass\": 1.898e27}, } # Calculate velocities results = {} for planet, data in planets.items(): R = data[\"radius\"] M = data[\"mass\"] v1 = np.sqrt(G * M / R) # First cosmic velocity v2 = np.sqrt(2) * v1 # Second cosmic velocity results[planet] = {\"v1\": v1 / 1000, \"v2\": v2 / 1000} # Convert to km/s # Visualization labels = list(results.keys()) v1_values = [results[planet][\"v1\"] for planet in labels] v2_values = [results[planet][\"v2\"] for planet in labels] x = np.arange(len(labels)) width = 0.35 fig, ax = plt.subplots() bar1 = ax.bar(x - width/2, v1_values, width, label=\"First Cosmic Velocity (v\u2081)\") bar2 = ax.bar(x + width/2, v2_values, width, label=\"Second Cosmic Velocity (v\u2082)\") ax.set_xlabel(\"Planets\") ax.set_ylabel(\"Velocity (km/s)\") ax.set_title(\"Cosmic Velocities for Various Planets\") ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.tight_layout() plt.savefig(\"./images/cosmic_velocities.png\") plt.show()","title":"3. Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-calculations-for-earth-mars-and-jupiter","text":"Planet Radius (km) Mass (kg) v\u2081 (km/s) v\u2082 (km/s) Earth 6,371 5.972 \u00d7 10\u00b2\u2074 7.91 11.2 Mars 3,390 6.39 \u00d7 10\u00b2\u00b3 3.55 5.03 Jupiter 69,911 1.898 \u00d7 10\u00b2\u2077 42.1 59.5 Note: First cosmic velocity \\( v_1 = \\sqrt{\\frac{G M}{R}} \\) Second cosmic velocity \\( v_2 = \\sqrt{\\frac{2 G M}{R}} \\)","title":"4. Calculations for Earth, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-visualization","text":"\ud83d\udcca Cosmic Velocities by Planet (You can generate this chart using matplotlib, plotting v\u2081 and v\u2082 side-by-side for each planet.)","title":"5. Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#6-importance-in-space-exploration","text":"First Cosmic Velocity: Used to place satellites into orbit (e.g., GPS, weather satellites). Second Cosmic Velocity: Required for interplanetary travel (e.g., Moon missions, Mars rovers). Third Cosmic Velocity: Relevant for interstellar missions (e.g., Voyager probes, theoretical deep space travel). These thresholds determine fuel requirements, propulsion design, and mission feasibility.","title":"6. Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"Understanding and applying cosmic velocities enables humanity to navigate space\u2014from orbiting Earth to reaching distant stars. Their derivation from basic physical laws illustrates the power of physics to guide cutting-edge technology and exploration.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Payload Released Near Earth 1. Types of Trajectories The trajectory of a payload near Earth depends on its initial velocity and position relative to Earth's center. These trajectories correspond to different conic sections: Elliptical Trajectory: Bound orbit, where total mechanical energy \\( E < 0 \\) . $$ v < v_{esc} $$ Parabolic Trajectory: Marginal escape, where total energy \\( E = 0 \\) . $$ v = v_{esc} $$ Hyperbolic Trajectory: Unbound escape, where total energy \\( E > 0 \\) . $$ v > v_{esc} $$ Suborbital (Ballistic) Trajectory: Insufficient velocity for orbit; returns to Earth. $$ v < v_{orb} $$ Key formula for escape velocity: $$ v_{esc} = \\sqrt{\\frac{2GM}{r}} $$ Where: - \\( G \\) = Gravitational constant - \\( M \\) = Mass of Earth - \\( r \\) = Distance from Earth's center 2. Mathematical Equations of Motion Using Newton's law of universal gravitation, the acceleration experienced by the payload is: \\[ \\vec{a} = -\\frac{GM}{r^3} \\vec{r} \\] Kinetic Energy (K): $$ K = \\frac{1}{2} m v^2 $$ Potential Energy (U): $$ U = -\\frac{G M m}{r} $$ Total Mechanical Energy (E): $$ E = K + U $$ 3. Python Simulation Click to expand Python code # filepath: /docs/1 Physics/3 Gravity/trajectories_simulation.py import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg R_earth = 6371e3 # m def gravitational_acceleration(r): return -G * M * r / np.linalg.norm(r)**3 def rk4_step(f, r, v, dt): k1_v = f(r) k1_r = v k2_v = f(r + 0.5*dt*k1_r) k2_r = v + 0.5*dt*k1_v k3_v = f(r + 0.5*dt*k2_r) k3_r = v + 0.5*dt*k2_v k4_v = f(r + dt*k3_r) k4_r = v + dt*k3_v r_next = r + (dt/6)*(k1_r + 2*k2_r + 2*k3_r + k4_r) v_next = v + (dt/6)*(k1_v + 2*k2_v + 2*k3_v + k4_v) return r_next, v_next # Simulation parameters dt = 1.0 # Time step (s) total_time = 10000 # Total simulation time (s) steps = int(total_time / dt) # Initial conditions altitude = 300e3 # 300 km speed = 7500 # m/s angle = np.radians(30) # 30 degrees r0 = np.array([R_earth + altitude, 0]) v0 = np.array([speed * np.cos(angle), speed * np.sin(angle)]) # Storage r = r0 v = v0 trajectory = [r] for _ in range(steps): r, v = rk4_step(gravitational_acceleration, r, v, dt) trajectory.append(r) if np.linalg.norm(r) <= R_earth: # Collision with Earth break trajectory = np.array(trajectory) # Plotting plt.figure(figsize=(8,8)) earth = plt.Circle((0, 0), R_earth, color='blue', alpha=0.5) plt.gca().add_patch(earth) plt.plot(trajectory[:,0], trajectory[:,1], color='red') plt.xlabel('x position (m)') plt.ylabel('y position (m)') plt.title('Payload Trajectory Near Earth') plt.axis('equal') plt.grid(True) plt.savefig(\"./images/payload_trajectory.png\") plt.show() 4. Visualization \ud83d\udcc8 Payload Trajectory Simulation The plot shows the motion of a payload launched at 7500 m/s at a 30\u00b0 angle, starting from 300 km altitude. If the trajectory does not achieve escape velocity, it either orbits Earth or reenters depending on speed and angle. 5. Escape Velocity vs Altitude The escape velocity decreases with altitude: \\[ v_{esc}(r) = \\sqrt{\\frac{2GM}{r}} \\] Click to expand Python code for Escape Velocity Plot # filepath: /docs/1 Physics/3 Gravity/escape_velocity_vs_altitude.py radii = np.linspace(R_earth, R_earth + 1000e3, 500) # 0 to 1000 km above surface v_esc = np.sqrt(2 * G * M / radii) plt.figure(figsize=(8,5)) plt.plot((radii - R_earth)/1000, v_esc/1000) # Altitude (km), Velocity (km/s) plt.xlabel('Altitude above Earth (km)') plt.ylabel('Escape Velocity (km/s)') plt.title('Escape Velocity vs Altitude') plt.grid(True) plt.savefig(\"./images/escape_velocity_vs_altitude.png\") plt.show() \ud83d\udcc8 Escape Velocity vs Altitude Escape velocity decreases from ~11.2 km/s at the surface to lower values with increasing altitude. 6. Relation to Orbital Insertion, Reentry, and Escape Scenario Description Required Speed Orbital Insertion Stable orbit achieved \\( v < v_{esc} \\) , circular/elliptical Reentry Suborbital or failed orbit, returns to Earth Insufficient speed Escape Leaves Earth's gravitational influence \\( v \\geq v_{esc} \\) Orbital insertion needs precise speed and angle. Reentry occurs if velocity is too low after release. Escape happens if \\( v \\geq v_{esc} \\) at given altitude. Conclusion Through energy and trajectory analysis, we find that payloads can enter bound orbits, reenter Earth's atmosphere, or escape into space depending on their initial conditions. Numerical simulation tools like Runge-Kutta integration allow detailed prediction of their paths, essential for real-world space missions.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-payload-released-near-earth","text":"","title":"Trajectories of a Payload Released Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-types-of-trajectories","text":"The trajectory of a payload near Earth depends on its initial velocity and position relative to Earth's center. These trajectories correspond to different conic sections: Elliptical Trajectory: Bound orbit, where total mechanical energy \\( E < 0 \\) . $$ v < v_{esc} $$ Parabolic Trajectory: Marginal escape, where total energy \\( E = 0 \\) . $$ v = v_{esc} $$ Hyperbolic Trajectory: Unbound escape, where total energy \\( E > 0 \\) . $$ v > v_{esc} $$ Suborbital (Ballistic) Trajectory: Insufficient velocity for orbit; returns to Earth. $$ v < v_{orb} $$ Key formula for escape velocity: $$ v_{esc} = \\sqrt{\\frac{2GM}{r}} $$ Where: - \\( G \\) = Gravitational constant - \\( M \\) = Mass of Earth - \\( r \\) = Distance from Earth's center","title":"1. Types of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-mathematical-equations-of-motion","text":"Using Newton's law of universal gravitation, the acceleration experienced by the payload is: \\[ \\vec{a} = -\\frac{GM}{r^3} \\vec{r} \\] Kinetic Energy (K): $$ K = \\frac{1}{2} m v^2 $$ Potential Energy (U): $$ U = -\\frac{G M m}{r} $$ Total Mechanical Energy (E): $$ E = K + U $$","title":"2. Mathematical Equations of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-python-simulation","text":"Click to expand Python code # filepath: /docs/1 Physics/3 Gravity/trajectories_simulation.py import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg R_earth = 6371e3 # m def gravitational_acceleration(r): return -G * M * r / np.linalg.norm(r)**3 def rk4_step(f, r, v, dt): k1_v = f(r) k1_r = v k2_v = f(r + 0.5*dt*k1_r) k2_r = v + 0.5*dt*k1_v k3_v = f(r + 0.5*dt*k2_r) k3_r = v + 0.5*dt*k2_v k4_v = f(r + dt*k3_r) k4_r = v + dt*k3_v r_next = r + (dt/6)*(k1_r + 2*k2_r + 2*k3_r + k4_r) v_next = v + (dt/6)*(k1_v + 2*k2_v + 2*k3_v + k4_v) return r_next, v_next # Simulation parameters dt = 1.0 # Time step (s) total_time = 10000 # Total simulation time (s) steps = int(total_time / dt) # Initial conditions altitude = 300e3 # 300 km speed = 7500 # m/s angle = np.radians(30) # 30 degrees r0 = np.array([R_earth + altitude, 0]) v0 = np.array([speed * np.cos(angle), speed * np.sin(angle)]) # Storage r = r0 v = v0 trajectory = [r] for _ in range(steps): r, v = rk4_step(gravitational_acceleration, r, v, dt) trajectory.append(r) if np.linalg.norm(r) <= R_earth: # Collision with Earth break trajectory = np.array(trajectory) # Plotting plt.figure(figsize=(8,8)) earth = plt.Circle((0, 0), R_earth, color='blue', alpha=0.5) plt.gca().add_patch(earth) plt.plot(trajectory[:,0], trajectory[:,1], color='red') plt.xlabel('x position (m)') plt.ylabel('y position (m)') plt.title('Payload Trajectory Near Earth') plt.axis('equal') plt.grid(True) plt.savefig(\"./images/payload_trajectory.png\") plt.show()","title":"3. Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-visualization","text":"\ud83d\udcc8 Payload Trajectory Simulation The plot shows the motion of a payload launched at 7500 m/s at a 30\u00b0 angle, starting from 300 km altitude. If the trajectory does not achieve escape velocity, it either orbits Earth or reenters depending on speed and angle.","title":"4. Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-escape-velocity-vs-altitude","text":"The escape velocity decreases with altitude: \\[ v_{esc}(r) = \\sqrt{\\frac{2GM}{r}} \\] Click to expand Python code for Escape Velocity Plot # filepath: /docs/1 Physics/3 Gravity/escape_velocity_vs_altitude.py radii = np.linspace(R_earth, R_earth + 1000e3, 500) # 0 to 1000 km above surface v_esc = np.sqrt(2 * G * M / radii) plt.figure(figsize=(8,5)) plt.plot((radii - R_earth)/1000, v_esc/1000) # Altitude (km), Velocity (km/s) plt.xlabel('Altitude above Earth (km)') plt.ylabel('Escape Velocity (km/s)') plt.title('Escape Velocity vs Altitude') plt.grid(True) plt.savefig(\"./images/escape_velocity_vs_altitude.png\") plt.show() \ud83d\udcc8 Escape Velocity vs Altitude Escape velocity decreases from ~11.2 km/s at the surface to lower values with increasing altitude.","title":"5. Escape Velocity vs Altitude"},{"location":"1%20Physics/2%20Gravity/Problem_3/#6-relation-to-orbital-insertion-reentry-and-escape","text":"Scenario Description Required Speed Orbital Insertion Stable orbit achieved \\( v < v_{esc} \\) , circular/elliptical Reentry Suborbital or failed orbit, returns to Earth Insufficient speed Escape Leaves Earth's gravitational influence \\( v \\geq v_{esc} \\) Orbital insertion needs precise speed and angle. Reentry occurs if velocity is too low after release. Escape happens if \\( v \\geq v_{esc} \\) at given altitude.","title":"6. Relation to Orbital Insertion, Reentry, and Escape"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"Through energy and trajectory analysis, we find that payloads can enter bound orbits, reenter Earth's atmosphere, or escape into space depending on their initial conditions. Numerical simulation tools like Runge-Kutta integration allow detailed prediction of their paths, essential for real-world space missions.","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface 1. Wave Equations and Superposition Wave Equation for a Single Source: The displacement \\( u \\) at a point \\( (x, y) \\) on the water surface, due to a single point source located at \\( (x_s, y_s) \\) , is given by the equation: $$ u(x, y, t) = A \\cos(k \\cdot r - \\omega t + \\phi) $$ where: \\( A \\) is the amplitude of the wave. \\( k = \\frac{2\\pi}{\\lambda} \\) is the wave number, with \\( \\lambda \\) being the wavelength. \\( \\omega = 2\\pi f \\) is the angular frequency, with \\( f \\) being the frequency of the wave. \\( r = \\sqrt{(x - x_s)^2 + (y - y_s)^2} \\) is the distance from the source to the observation point. \\( \\phi \\) is the initial phase. Superposition Principle: When multiple sources emit waves, the total displacement at any point \\( (x, y) \\) on the water surface is the sum of the displacements from all the sources: $$ u_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} A \\cos(k \\cdot r_i - \\omega t + \\phi_i) $$ where \\( N \\) is the number of sources (the vertices of the polygon), and \\( r_i \\) is the distance from the point \\( (x, y) \\) to the \\( i \\) -th source. 2. Mathematical Derivations Displacement for Multiple Sources: Given that the sources are placed at the vertices of a regular polygon, the resulting displacement at any point \\( (x, y) \\) is the sum of the individual wave contributions from each vertex: $$ u_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} A \\cos(k \\cdot r_i - \\omega t + \\phi_i) $$ where: \\( r_i = \\sqrt{(x - x_s)^2 + (y - y_s)^2} \\) is the distance from the source at \\( (x_s, y_s) \\) to the point \\( (x, y) \\) . \\( N \\) is the number of vertices in the polygon, with the sources placed at equal angles. 3. Python Simulation Click to expand Python code # filepath: /docs/1 Physics/2 Wave Interference/interference_pattern_simulation.py import numpy as np import matplotlib.pyplot as plt # Parameters for the wave A = 1.0 # Amplitude lambda_wave = 2.0 # Wavelength f = 1.0 # Frequency (Hz) omega = 2 * np.pi * f # Angular frequency k = 2 * np.pi / lambda_wave # Wave number phi = 0 # Initial phase # Number of sources (vertices of the polygon) N = 4 # For square (can change for other polygons) r = 5 # Distance from the center to each vertex # Function to generate the positions of the sources def get_source_positions(N, r): angles = np.linspace(0, 2 * np.pi, N, endpoint=False) positions = [(r * np.cos(angle), r * np.sin(angle)) for angle in angles] return positions # Function to compute the displacement from a single wave source at (x_s, y_s) def wave_displacement(x, y, x_s, y_s, A, k, omega, t, phi): r = np.sqrt((x - x_s)**2 + (y - y_s)**2) # Distance from the source return A * np.cos(k * r - omega * t + phi) # Function to compute total displacement due to superposition of waves from multiple sources def total_displacement(x, y, sources, A, k, omega, t, phi): total_disp = 0 for (x_s, y_s) in sources: total_disp += wave_displacement(x, y, x_s, y_s, A, k, omega, t, phi) return total_disp # Generate the grid for the water surface x_vals = np.linspace(-10, 10, 400) y_vals = np.linspace(-10, 10, 400) X, Y = np.meshgrid(x_vals, y_vals) # Get the positions of the sources (vertices of the square) sources = get_source_positions(N, r) # Create an empty matrix for the displacement Z = np.zeros(X.shape) # Time array to animate the wave time = 0.0 # Set time for one snapshot of the pattern # Compute the displacement at each point on the grid for i in range(len(x_vals)): for j in range(len(y_vals)): Z[i, j] = total_displacement(X[i, j], Y[i, j], sources, A, k, omega, time, phi) # Plot the interference pattern (snapshot at time = 0) plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, 50, cmap='RdBu_r') plt.colorbar(label='Displacement') plt.title('Interference Pattern from 4 Point Sources (Square)') plt.xlabel('X') plt.ylabel('Y') plt.show() 4. Interference Patterns and Analysis Constructive Interference: Constructive interference occurs when the waves from different sources meet in phase, leading to amplified displacement. These regions appear as peaks in the interference pattern. Destructive Interference: Destructive interference happens when the waves from different sources meet out of phase, leading to cancellation. These regions appear as troughs or points of zero displacement in the interference pattern. Effect of Source Configuration: The number and arrangement of sources (vertices of the polygon) will determine the pattern of constructive and destructive interference. A square configuration (4 sources) results in a symmetric pattern, while an equilateral triangle (3 sources) would create a different interference pattern with fewer peaks. 5. Graphical Representation \ud83d\udcca Interference Pattern from 4 Point Sources (The graph shows the resulting interference pattern from four point sources arranged in a square configuration.) 6. Importance of Wave Interference Wave Superposition: The principle of superposition plays a crucial role in understanding how waves interact. It allows us to predict the resulting wave pattern from multiple sources. Applications: Wave interference patterns are seen in various real-world scenarios, such as water waves, light waves, and sound waves. Understanding how these patterns form can be applied in areas such as acoustics, optics, and oceanography. Conclusion By simulating and analyzing the interference patterns on a water surface due to waves from multiple sources, we gain valuable insights into the nature of wave superposition. The patterns of constructive and destructive interference provide a clear illustration of how waves combine, and they can be used to explore deeper principles in wave physics.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-wave-equations-and-superposition","text":"Wave Equation for a Single Source: The displacement \\( u \\) at a point \\( (x, y) \\) on the water surface, due to a single point source located at \\( (x_s, y_s) \\) , is given by the equation: $$ u(x, y, t) = A \\cos(k \\cdot r - \\omega t + \\phi) $$ where: \\( A \\) is the amplitude of the wave. \\( k = \\frac{2\\pi}{\\lambda} \\) is the wave number, with \\( \\lambda \\) being the wavelength. \\( \\omega = 2\\pi f \\) is the angular frequency, with \\( f \\) being the frequency of the wave. \\( r = \\sqrt{(x - x_s)^2 + (y - y_s)^2} \\) is the distance from the source to the observation point. \\( \\phi \\) is the initial phase. Superposition Principle: When multiple sources emit waves, the total displacement at any point \\( (x, y) \\) on the water surface is the sum of the displacements from all the sources: $$ u_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} A \\cos(k \\cdot r_i - \\omega t + \\phi_i) $$ where \\( N \\) is the number of sources (the vertices of the polygon), and \\( r_i \\) is the distance from the point \\( (x, y) \\) to the \\( i \\) -th source.","title":"1. Wave Equations and Superposition"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-mathematical-derivations","text":"Displacement for Multiple Sources: Given that the sources are placed at the vertices of a regular polygon, the resulting displacement at any point \\( (x, y) \\) is the sum of the individual wave contributions from each vertex: $$ u_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} A \\cos(k \\cdot r_i - \\omega t + \\phi_i) $$ where: \\( r_i = \\sqrt{(x - x_s)^2 + (y - y_s)^2} \\) is the distance from the source at \\( (x_s, y_s) \\) to the point \\( (x, y) \\) . \\( N \\) is the number of vertices in the polygon, with the sources placed at equal angles.","title":"2. Mathematical Derivations"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-python-simulation","text":"Click to expand Python code # filepath: /docs/1 Physics/2 Wave Interference/interference_pattern_simulation.py import numpy as np import matplotlib.pyplot as plt # Parameters for the wave A = 1.0 # Amplitude lambda_wave = 2.0 # Wavelength f = 1.0 # Frequency (Hz) omega = 2 * np.pi * f # Angular frequency k = 2 * np.pi / lambda_wave # Wave number phi = 0 # Initial phase # Number of sources (vertices of the polygon) N = 4 # For square (can change for other polygons) r = 5 # Distance from the center to each vertex # Function to generate the positions of the sources def get_source_positions(N, r): angles = np.linspace(0, 2 * np.pi, N, endpoint=False) positions = [(r * np.cos(angle), r * np.sin(angle)) for angle in angles] return positions # Function to compute the displacement from a single wave source at (x_s, y_s) def wave_displacement(x, y, x_s, y_s, A, k, omega, t, phi): r = np.sqrt((x - x_s)**2 + (y - y_s)**2) # Distance from the source return A * np.cos(k * r - omega * t + phi) # Function to compute total displacement due to superposition of waves from multiple sources def total_displacement(x, y, sources, A, k, omega, t, phi): total_disp = 0 for (x_s, y_s) in sources: total_disp += wave_displacement(x, y, x_s, y_s, A, k, omega, t, phi) return total_disp # Generate the grid for the water surface x_vals = np.linspace(-10, 10, 400) y_vals = np.linspace(-10, 10, 400) X, Y = np.meshgrid(x_vals, y_vals) # Get the positions of the sources (vertices of the square) sources = get_source_positions(N, r) # Create an empty matrix for the displacement Z = np.zeros(X.shape) # Time array to animate the wave time = 0.0 # Set time for one snapshot of the pattern # Compute the displacement at each point on the grid for i in range(len(x_vals)): for j in range(len(y_vals)): Z[i, j] = total_displacement(X[i, j], Y[i, j], sources, A, k, omega, time, phi) # Plot the interference pattern (snapshot at time = 0) plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, 50, cmap='RdBu_r') plt.colorbar(label='Displacement') plt.title('Interference Pattern from 4 Point Sources (Square)') plt.xlabel('X') plt.ylabel('Y') plt.show()","title":"3. Python Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-interference-patterns-and-analysis","text":"Constructive Interference: Constructive interference occurs when the waves from different sources meet in phase, leading to amplified displacement. These regions appear as peaks in the interference pattern. Destructive Interference: Destructive interference happens when the waves from different sources meet out of phase, leading to cancellation. These regions appear as troughs or points of zero displacement in the interference pattern. Effect of Source Configuration: The number and arrangement of sources (vertices of the polygon) will determine the pattern of constructive and destructive interference. A square configuration (4 sources) results in a symmetric pattern, while an equilateral triangle (3 sources) would create a different interference pattern with fewer peaks.","title":"4. Interference Patterns and Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-graphical-representation","text":"\ud83d\udcca Interference Pattern from 4 Point Sources (The graph shows the resulting interference pattern from four point sources arranged in a square configuration.)","title":"5. Graphical Representation"},{"location":"1%20Physics/3%20Waves/Problem_1/#6-importance-of-wave-interference","text":"Wave Superposition: The principle of superposition plays a crucial role in understanding how waves interact. It allows us to predict the resulting wave pattern from multiple sources. Applications: Wave interference patterns are seen in various real-world scenarios, such as water waves, light waves, and sound waves. Understanding how these patterns form can be applied in areas such as acoustics, optics, and oceanography.","title":"6. Importance of Wave Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"By simulating and analyzing the interference patterns on a water surface due to waves from multiple sources, we gain valuable insights into the nature of wave superposition. The patterns of constructive and destructive interference provide a clear illustration of how waves combine, and they can be used to explore deeper principles in wave physics.","title":"Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory 1. Introduction to Graph Theory for Circuits Circuit Representation as a Graph: A circuit can be represented as a graph, where: Nodes represent the junctions (connection points between resistors), Edges represent resistors with weights equal to their resistance values. This graph-based approach allows for the use of graph theory algorithms to simplify and analyze complex electrical circuits. Goal: The goal is to calculate the equivalent resistance of a circuit by iteratively simplifying series and parallel resistor connections. This approach eliminates the need for manual identification of series and parallel connections and reduces the circuit to a single equivalent resistance. 2. Algorithm Description Identifying Series and Parallel Connections: Series Connection: Resistors are in series if they are connected end-to-end with no intermediate junction. The equivalent resistance for two resistors \\( R_1 \\) and \\( R_2 \\) in series is: $$ R_{\\text{eq}} = R_1 + R_2 $$ Parallel Connection: Resistors are in parallel if they share both ends at the same junction. The equivalent resistance for two resistors \\( R_1 \\) and \\( R_2 \\) in parallel is: $$ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} $$ or equivalently: $$ R_{\\text{eq}} = \\frac{R_1 \\cdot R_2}{R_1 + R_2} $$ Iterative Graph Reduction: The circuit is iteratively simplified by detecting series and parallel connections. After identifying and simplifying a connection, the new equivalent resistor is added back to the graph. This process repeats until only one equivalent resistance remains. Handling Nested Configurations: For circuits with nested series and parallel connections, the algorithm applies the reduction rules recursively. If a combination of resistors is simplified into a single equivalent resistor, this newly formed resistor might itself be part of a more complex combination, requiring further simplification. 3. Pseudocode def calculate_equivalent_resistance(circuit_graph): # Step 1: Simplify series connections while series_connections_exist(circuit_graph): simplify_series(circuit_graph) # Step 2: Simplify parallel connections while parallel_connections_exist(circuit_graph): simplify_parallel(circuit_graph) # Step 3: Return the final equivalent resistance return circuit_graph[0] # Assuming only one node remains, holding the final equivalent resistance def series_connections_exist(circuit_graph): # Check if there are any series connections for node in circuit_graph: if is_series_connection(node): return True return False def parallel_connections_exist(circuit_graph): # Check if there are any parallel connections for node in circuit_graph: if is_parallel_connection(node): return True return False def simplify_series(circuit_graph): # Find two resistors in series and combine them node = find_series_nodes(circuit_graph) combined_resistance = node[0].resistance + node[1].resistance remove_resistors(circuit_graph, node) add_combined_resistor(circuit_graph, node, combined_resistance) def simplify_parallel(circuit_graph): # Find two resistors in parallel and combine them node = find_parallel_nodes(circuit_graph) combined_resistance = (node[0].resistance * node[1].resistance) / (node[0].resistance + node[1].resistance) remove_resistors(circuit_graph, node) add_combined_resistor(circuit_graph, node, combined_resistance) def is_series_connection(node): # Check if two resistors are in series return node.has_series_neighbors() def is_parallel_connection(node): # Check if two resistors are in parallel return node.has_parallel_neighbors() def find_series_nodes(circuit_graph): # Identify and return two nodes connected in series pass def find_parallel_nodes(circuit_graph): # Identify and return two nodes connected in parallel pass 4. Test Cases and Examples Example 1: Simple Series and Parallel Combinations Consider a circuit with two resistors \\( R_1 = 10 \\, \\Omega \\) and \\( R_2 = 5 \\, \\Omega \\) . Series Combination : The total resistance for resistors in series is simply the sum: $$ R_{\\text{eq}} = R_1 + R_2 = 10 + 5 = 15 \\, \\Omega $$ Parallel Combination : The total resistance for resistors in parallel is given by the formula: $$ R_{\\text{eq}} = \\frac{R_1 \\cdot R_2}{R_1 + R_2} = \\frac{10 \\cdot 5}{10 + 5} = \\frac{50}{15} = 3.33 \\, \\Omega $$ Example 2: Nested Configurations Consider a circuit with: - \\( R_1 = 10 \\, \\Omega \\) , \\( R_2 = 5 \\, \\Omega \\) in series, and - \\( R_3 = 15 \\, \\Omega \\) in parallel with the series combination of \\( R_1 \\) and \\( R_2 \\) . Simplify Series Combination : $$ R_{\\text{series}} = R_1 + R_2 = 10 + 5 = 15 \\, \\Omega $$ Simplify Parallel Combination with \\( R_3 \\) : $$ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_{\\text{series}}} + \\frac{1}{R_3} = \\frac{1}{15} + \\frac{1}{15} = \\frac{2}{15} \\quad \\Rightarrow \\quad R_{\\text{eq}} = 7.5 \\, \\Omega $$ Example 3: Complex Graph with Cycles For a more complex circuit containing cycles, the algorithm uses depth-first search (DFS) or breadth-first search (BFS) techniques to identify cycles and simplify the circuit. By detecting these cycles, the algorithm can apply Kirchhoff's laws or reduction techniques, recursively simplifying the circuit until it converges to a single equivalent resistance. The algorithm is designed to handle these cycles efficiently and compute the final equivalent resistance using graph traversal methods. 5. Efficiency and Potential Improvements Efficiency: The algorithm works efficiently for small to moderately complex circuits by iteratively simplifying series and parallel resistor combinations. For very large circuits, the complexity may increase as each simplification step involves checking the graph for series and parallel connections, which could be computationally expensive. Potential Improvements: Cycle Detection: For circuits with multiple loops, advanced cycle detection techniques (e.g., using Kirchhoff\u2019s circuit laws) could further optimize the simplification process. Graph Representation: Optimizing the graph representation (e.g., using adjacency lists or matrices) could improve the efficiency of graph traversal and make the overall process faster. Conclusion By using graph theory to represent and analyze electrical circuits, this algorithm simplifies the task of calculating the equivalent resistance. The iterative reduction of series and parallel connections provides an efficient method for handling both simple and complex circuits, including those with nested and cyclical resistor configurations. This approach not only simplifies circuit analysis but also enhances the ability to automate and optimize the process, making it ideal for applications in circuit simulation and design.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-introduction-to-graph-theory-for-circuits","text":"Circuit Representation as a Graph: A circuit can be represented as a graph, where: Nodes represent the junctions (connection points between resistors), Edges represent resistors with weights equal to their resistance values. This graph-based approach allows for the use of graph theory algorithms to simplify and analyze complex electrical circuits. Goal: The goal is to calculate the equivalent resistance of a circuit by iteratively simplifying series and parallel resistor connections. This approach eliminates the need for manual identification of series and parallel connections and reduces the circuit to a single equivalent resistance.","title":"1. Introduction to Graph Theory for Circuits"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-algorithm-description","text":"Identifying Series and Parallel Connections: Series Connection: Resistors are in series if they are connected end-to-end with no intermediate junction. The equivalent resistance for two resistors \\( R_1 \\) and \\( R_2 \\) in series is: $$ R_{\\text{eq}} = R_1 + R_2 $$ Parallel Connection: Resistors are in parallel if they share both ends at the same junction. The equivalent resistance for two resistors \\( R_1 \\) and \\( R_2 \\) in parallel is: $$ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} $$ or equivalently: $$ R_{\\text{eq}} = \\frac{R_1 \\cdot R_2}{R_1 + R_2} $$ Iterative Graph Reduction: The circuit is iteratively simplified by detecting series and parallel connections. After identifying and simplifying a connection, the new equivalent resistor is added back to the graph. This process repeats until only one equivalent resistance remains. Handling Nested Configurations: For circuits with nested series and parallel connections, the algorithm applies the reduction rules recursively. If a combination of resistors is simplified into a single equivalent resistor, this newly formed resistor might itself be part of a more complex combination, requiring further simplification.","title":"2. Algorithm Description"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-pseudocode","text":"def calculate_equivalent_resistance(circuit_graph): # Step 1: Simplify series connections while series_connections_exist(circuit_graph): simplify_series(circuit_graph) # Step 2: Simplify parallel connections while parallel_connections_exist(circuit_graph): simplify_parallel(circuit_graph) # Step 3: Return the final equivalent resistance return circuit_graph[0] # Assuming only one node remains, holding the final equivalent resistance def series_connections_exist(circuit_graph): # Check if there are any series connections for node in circuit_graph: if is_series_connection(node): return True return False def parallel_connections_exist(circuit_graph): # Check if there are any parallel connections for node in circuit_graph: if is_parallel_connection(node): return True return False def simplify_series(circuit_graph): # Find two resistors in series and combine them node = find_series_nodes(circuit_graph) combined_resistance = node[0].resistance + node[1].resistance remove_resistors(circuit_graph, node) add_combined_resistor(circuit_graph, node, combined_resistance) def simplify_parallel(circuit_graph): # Find two resistors in parallel and combine them node = find_parallel_nodes(circuit_graph) combined_resistance = (node[0].resistance * node[1].resistance) / (node[0].resistance + node[1].resistance) remove_resistors(circuit_graph, node) add_combined_resistor(circuit_graph, node, combined_resistance) def is_series_connection(node): # Check if two resistors are in series return node.has_series_neighbors() def is_parallel_connection(node): # Check if two resistors are in parallel return node.has_parallel_neighbors() def find_series_nodes(circuit_graph): # Identify and return two nodes connected in series pass def find_parallel_nodes(circuit_graph): # Identify and return two nodes connected in parallel pass","title":"3. Pseudocode"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-test-cases-and-examples","text":"Example 1: Simple Series and Parallel Combinations Consider a circuit with two resistors \\( R_1 = 10 \\, \\Omega \\) and \\( R_2 = 5 \\, \\Omega \\) . Series Combination : The total resistance for resistors in series is simply the sum: $$ R_{\\text{eq}} = R_1 + R_2 = 10 + 5 = 15 \\, \\Omega $$ Parallel Combination : The total resistance for resistors in parallel is given by the formula: $$ R_{\\text{eq}} = \\frac{R_1 \\cdot R_2}{R_1 + R_2} = \\frac{10 \\cdot 5}{10 + 5} = \\frac{50}{15} = 3.33 \\, \\Omega $$ Example 2: Nested Configurations Consider a circuit with: - \\( R_1 = 10 \\, \\Omega \\) , \\( R_2 = 5 \\, \\Omega \\) in series, and - \\( R_3 = 15 \\, \\Omega \\) in parallel with the series combination of \\( R_1 \\) and \\( R_2 \\) . Simplify Series Combination : $$ R_{\\text{series}} = R_1 + R_2 = 10 + 5 = 15 \\, \\Omega $$ Simplify Parallel Combination with \\( R_3 \\) : $$ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_{\\text{series}}} + \\frac{1}{R_3} = \\frac{1}{15} + \\frac{1}{15} = \\frac{2}{15} \\quad \\Rightarrow \\quad R_{\\text{eq}} = 7.5 \\, \\Omega $$ Example 3: Complex Graph with Cycles For a more complex circuit containing cycles, the algorithm uses depth-first search (DFS) or breadth-first search (BFS) techniques to identify cycles and simplify the circuit. By detecting these cycles, the algorithm can apply Kirchhoff's laws or reduction techniques, recursively simplifying the circuit until it converges to a single equivalent resistance. The algorithm is designed to handle these cycles efficiently and compute the final equivalent resistance using graph traversal methods.","title":"4. Test Cases and Examples"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-efficiency-and-potential-improvements","text":"Efficiency: The algorithm works efficiently for small to moderately complex circuits by iteratively simplifying series and parallel resistor combinations. For very large circuits, the complexity may increase as each simplification step involves checking the graph for series and parallel connections, which could be computationally expensive. Potential Improvements: Cycle Detection: For circuits with multiple loops, advanced cycle detection techniques (e.g., using Kirchhoff\u2019s circuit laws) could further optimize the simplification process. Graph Representation: Optimizing the graph representation (e.g., using adjacency lists or matrices) could improve the efficiency of graph traversal and make the overall process faster.","title":"5. Efficiency and Potential Improvements"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#conclusion","text":"By using graph theory to represent and analyze electrical circuits, this algorithm simplifies the task of calculating the equivalent resistance. The iterative reduction of series and parallel connections provides an efficient method for handling both simple and complex circuits, including those with nested and cyclical resistor configurations. This approach not only simplifies circuit analysis but also enhances the ability to automate and optimize the process, making it ideal for applications in circuit simulation and design.","title":"Conclusion"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}